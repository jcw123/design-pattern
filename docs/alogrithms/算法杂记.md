# 算法

## 类型汇总

### 基本
1. 数组
2. 字符串
3. 排序
4. 矩阵
5. 模拟
6. 枚举
7. 字符串匹配
8. 桶排序
9. 计数排序
10. 基数排序

### 常见算法
1. 动态规划
2. 深度优先搜索
3. 贪心
4. 广度优先搜索
5. 二分查找
6. 回溯
7. 递归
8. 分治
9. 记忆化搜索
10. 归并排序
11. 快速选择

### 基础数据结构
1. 哈希表
2. 树
3. 二叉树
4. 栈
5. 堆
6. 图
7. 链表
8. 二分搜索树
9. 单调栈
10. 有序集合
11. 队列
12. 拓扑排序
13. 最短路
14. 单调队列
15. 双向链表
16. 最小生成树
17. 欧拉回路
18. 强连通分量
19. 双连通分量

### 高级数据结构
1. 并查集
2. 字典树
3. 线段树
4. 树状数组
5. 后缀数组

### 技巧
1. 双指针
2. 位运算
3. 前缀和
4. 计数
5. 滑动窗口
6. 状态压缩
7. 哈希函数
8. 滚动哈希
9. 扫描线

### 数学

### 其他

## 思考
1. 核心的思想就那么些，主要的还是需要提升思维的层次；就拿之前的链表找环来说，如果从不同的层次进行理解，解题的难易也有所不同；

2. 借助于Trie数据结构，可以解决很懂问题，如果数据元素很多，可以利用Trie构建树形结构，极大降低问题复杂度；

3. 前缀和的思想能够降低问题的复杂度，比如：判断数组中的子数组和等于target的个数；子矩阵之和等于target的个数
- 1074:元素和为目标值的子矩阵数量

4. 如果元素本身具有一些特性，可以利用元素本身的特点进行一些优化，比如排序操作，如果元素的是正整数，且元素的最大值比较小，就可以直接利用元素自身的特点在O(n)的时间复杂度下进行排序；

5. 如果只能按照顺序遍历元素，采用二分法和贪心法说不定能够带来很好的效果，上下界的确定可以利用元素之和，之积的方式，例如：LCP12小张刷题计划;LCP08剧情触发时间(挺难的，思路有一点点错乱)
