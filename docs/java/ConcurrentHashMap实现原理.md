只针对1.8版本的ConcurrentHashMap进行讲解

> 参考文档：https://www.jianshu.com/p/5dbaa6707017

**底层借助于CAS + synchronized实现了线程安全。**

**数据结构是数组 + 链表 + 红黑树**

1、put操作过程
 - 如果put时发现还没有进行初始化，会通过cas方式进行初始化操作；
 - 如果插入元素时发现对应的节点位置为空，也是通过cas操作进行插入操作；
 - 如果正在执行transfer操作，帮助转换，加快转换速度；
 - 如果对应的位置有值，则首先对头结点通过synchronized进行加锁操作，对应的节点结构可能是链表或者红黑树，基于
 不同的结构进行插入操作；数据插入后，如果是链表结构，插入导致链表节点长度过长，会转换为红黑树结构；
 > addCount方法中会判断数组中所占槽位的个数是否超过loadFactor，如果超过会进行扩容；
 链表的插入操作是在链表的尾部，1.7版本之前都是头部，像HashMap这样的非线程安全如果采用头插发，容易造成链循环。

2、get操作过程
- hashcode找对应的位置，通过equals方法找到对应的值，如果是链表结构直接一个个找即可。如果是红黑树结构，调用红黑树的查找方法

3. remove操作

4. containsKey操作

5. 链表结构和红黑树结构转换时机

- 核心参数
  - TREEIFY_THRESHOLD
  默认值是8，当插入元素时，如果发现一个链表中元素长度大于8，则会将链表转为红黑树结构；
  涉及方法：merge、putVal、compute、computeIfAbsent

  - UNTREEIFY_THRESHOLD
  默认值是6，当删除元素时，如果节点的数据结构是红黑树，会将红黑树结构转为链表

  - MIN_TREEIFY_CAPACITY
  默认值是64，如果需要转为红黑树，则数组中的长度至少是这个值，也就是说，如果由于一个节点的链表过长了导致需要treeify操作，首先考虑扩容重hash，如果还是过长的话才转为红黑树；

- 核心方法
  - untreeify
  将红黑树结构转为链表结构，当删除元素或者进行resize操作时都会导致一个节点的元素个数小于treeifyBin这个值；

  - treeifyBin
  将链表结构转为红黑树结构，当添加元素或者进行resize操作时都会导致一个节点的元素个数大于treeifyBin这个值；
