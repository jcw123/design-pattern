一、 HotSpot虚拟机内部的即时编译器
1、解释器和编译器
-Xint强制以解释器模式运行
-Xcomp强制以编译模式运行，但编译模式无法完成工作时，会回退以解释模式运行
默认以混合模式运行

2、编译对象和触发条件

编译器编译的”热点代码”与两类：
> 类似一份经常调用的任务，如果可以提前将结果缓存起来，提升效率；

（1）被多次调用的方法 （标准的JIT编译）
（2）被多次执行的循环体 （OSR 编译）

探测热点代码的两种方式：
（1）基于采样的热点探测
周期性的检查线程的栈顶，如果某个方法经常出现在栈顶，则可评为“热点方法”
（2）基于计数器的热点探测
给每一个方法建议一个计数器，统计方法的调用次数，每个方法包含两类计数器：方法调用计数器和回边计数器


二、常见的编译优化技术
1、编译器策略
2、基于性能监控的优化技术
3、基于证据的优化技术
4、数据流敏感重写
5、语言相关的优化技术
6、内存及代码位置变换
7、循环变换
8、全局代码调整
9、控制流变换

常见的优化说明：
1、 数据边界检查消除
如果每次访问时都进行数据边界检查，将导致程序比较耗时，如果在编译时能够确定边界不会溢出，可以将边界检查消除
2、方法内联
> 减少栈帧的创建，创建栈帧也是有一点耗时的，那平常使用的递归方法如果可以使用非递归的方式，可以进行优化；

将调用方法的地方直接用方法的代码替代，可以减少栈帧的创建，像私有方法、实例构造器、父类方法和静态方法可以直接替换外，虚方法存在多态性，替换起来比较麻烦，需要有专门的分析技术确认是否可替换，是一种激进优化，如果失败，需要退回到解释执行。
3、逃逸分析
> 就是一个纯粹的局部变量，随着方法的退出，变量就没有引用了，可以直接在栈上分配；

逃逸分析的基本功能就是分析对象的动态作用域。在方法内部定义的变量，如果可能被外部方法访问到，则称为方法逃逸；如果能被其他线程访问到，则称之为线程逃逸。
如果能够证明变量不会逃逸到方法或者线程之外，可以进行如下优化：
栈上分配：对象不在堆上分配，直接在栈上分配。
同步消除：将同步措施消除掉
标量替换：不直接创建对象，而是直接创建成员变量
