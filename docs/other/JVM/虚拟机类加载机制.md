一、类加载的时机
1、类加载到卸载的整个生命周期分为如下几个步骤：
加载（Loading）-》验证（Verification）-》准备（Preparation）-》解析（Resolution）-》初始化（Initialization）-》使用（Using）-》卸载（Unloading）
其中验证、准备、解析统称为连接阶段。

2、有且只有5中情况必须对类进行“初始化”：
（1）遇到new、getstatic、putstatic和invokestatic这4条指令的时候，如果没有初始化需要进行初始化，常见场景：使用new关键字实例化对象的时候，读取或者设置一个类的静态字段，以及调用一个类的静态方法的时候
（2）使用java.lang.reflect包的方法对类进行反射调用的时候
（3）当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发父类的初始化
（4）当虚拟机启动的时候，用户需要指定一个要执行的主类，虚拟机要先初始化这个主类
（5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle最后的解析结果REF_getStatic、
REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，需要先触发初始化。
> 上述5中情况都是对类的主动引用，除了这5种情况之外，所有对类的引用都不会触发初始化 ，称为被动引用。对于接口的初始化，第三种情况与类不同，对于接口初始化时，并不要求初始化其父类，只有真正要使用父类时才会初始化父类。

二、类的加载过程
1、加载
（1）加载阶段完成三件事：
通过一个类的全限定名获取定义此类的二进制字节流；
将这个字节流所对应的静态存储结构转化为方法区的运行时数据结构
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口
> 二进制字节流可以来自多种地方：从Zip包、Jar包、War包中读取；从网络中读取；运行时动态生成，如动态代理技术；由其他文件生成；从数据库中获取等
加载和连接阶段可能是交叉进行的（如一部分字节码文件格式的验证阶段）

2、验证
>主要是验证字节流是否符合虚拟机规范，防止危害虚拟机自身的安全

大致分为四个阶段的校验：
（1）文件格式的校验
如魔数校验、版本号校验、常量类型校验、索引校验等等，经过这个阶段的校验，字节流就会进入内存的方法区进行存储
（2）元数据校验
例如：这个类是否有父类、这个类的父类是否继承了不允许继承的父类、类中的字段、方法是否与父类产生矛盾等等。这一阶段是对类的元数据进行语义校验
（3）字节码校验
主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。即对方法体进行校验
（4）符号引用校验
目的是确保解析动作能正常执行，主要校验的内容：符号引用中通过字符串描述的全限定名是否能找到对应的类，符号引用中的类、字段、方法的访问性是否可以被当前类访问等等。

3、准备
准备阶段是正式为类变量分配内存并设置类变量初始值（数据类型的默认零值）的阶段，这些变量所使用的内存都将在方法区中分配，如果字段被final修饰，则在准备阶段就将对象的值赋值为传递的值（public static final int x = 123; 则在这个阶段x的值就变为123，如果没有final修饰，则在这个阶段x的值时0）

4、解析
>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用于内存布局无关，而直接引用是与内存布局有关的

（1）类或接口的解析
（2）字段解析
（3）类方法解析
（4）接口方法解析

5、初始化
(1)初始化过程就是执行<clinit>()方法的过程，这个方法是由编译器收集类中的所有类变量的赋值动作和静态语句块的语句合并产生的。在执行子类的<clinit>方法之外，必须保证父类的这个方法已经执行完成，即父类的静态语句块比子类的语句块先执行。
(2)如果类中没有静态语句块和静态变量的赋值操作，则就不会产生<clinit>这个方法。对于接口，不需要保证父接口的这个方法必须执行，只有用到时才会执行。

三、类加载器
比较两个类是否相等，需要保证两个类来源于同一个Class文件，并且被同一个类加载器加载。
如果想破坏双亲委派模型结构，必须给出充足的理由，比如OSGi为了实现模块化部署，破坏了双亲委派结构
