一、线程安全

1、各种共享的数据可以分为五类：
（1）不变性
使用final关键字修饰的变量
（2）绝对线程安全
Vector集合类是线程安全的，但也不是绝对线程安全的。
（3）相对线程安全
> 虽然单独操作是线程安全的，但是复合操作不是线程安全的，所以叫相对线程安全；

需要保证对对象的单独的操作是线程安全的，不需要做额外的保证措施，常见的线程安全类就属于这种类型。如：Vector、Hashtable等。
（4）线程兼容
对象本身不是线程安全的，但可以通过在调用端正确地使用同步手段保证对象在并发环境里正确地使用。
(5)线程对立
> 没见过。。

无论调用端采取什么同步措施，都无法在多线程环境并发使用的代码。

2、线程安全的实现方法
（1）互斥同步
通过synchronized关键字修饰等
（2）非阻塞同步
通过操作系统新增的硬件指令来保证CAS
（3）无同步方案
像可重入代码或者利用线程本地存储可以保证无需同步


二、锁优化
常见的优化技术：适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。

1、自旋锁和自适应自旋
对于阻塞等待的同步，线程阻塞和恢复，都需要由用户态切换到内核态，花费很大，因此不让线程进入阻塞状态，空转一会，等待获取CPU时间
> 自旋锁挺好，但是自旋状态不能太长，不然会浪费大量的cpu时间；

2、锁消除
没有对象共享，比如StringBuffer类的append操作，就可以通过即时编译消除掉锁

3、锁粗化
如果存在多次的加锁/解锁操作，可以将加锁操作往外层作用域提取。

4、轻量级锁
轻量级是相对于使用操作系统信号量来实现传统锁而言的。java中通过对象头的标志位来实现轻量级锁，通过CAS实现来实现加锁和解锁。

5、偏向锁
> 偏向于第一个获取锁的线程，如果之后没有其他线程获取锁，则第一个线程再次进行同步块时不需要进行同步操作； 

轻量级锁在无竞争情况下使用CAS操作消除同步使用的互斥量，偏向锁在无竞争情况下把整个同步消除掉。
在无竞争的情况下，对于获取偏向锁的这个线程，下次进入同步块时不需要进行锁定。
