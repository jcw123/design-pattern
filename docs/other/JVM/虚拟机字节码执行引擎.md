一、运行时栈帧结构
1、局部变量表
基本单位：Slot，可以复用
作用：主要用于存储方法参数和方法内定义的局部变量
注：对于不使用的大对象，要及时将对象设置为null，则在下次垃圾回收时，能够保证对象引用尽可能少，有利于垃圾回收。
类变量在连接阶段中的准备阶段就为其赋初始值，而局部变量不同，如果没有手动赋初始值，是不能使用的。

2、操作数栈
栈的最大深度在编译时就已确定，存放在方法信息的Code属性的max_stacks数据项上。

3、动态连接
每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用，通过这个引用支持动态连接
静态解析：类加载阶段或者第一次使用的时候符号引用转为直接引用
动态解析：在每次运行期间转为直接引用

4、方法返回地址
两种方法退出当前方法：遇到返回指令正常退出；在执行过程中遇到了异常，方法返回时涉及栈顶栈帧的出栈，同时恢复上一层方法的局部变量表和操作数栈。

二、方法调用
方法调用不等同于方法执行，方法调用阶段唯一的任务是确定被调用方法的版本。编译期间值包含方法的符号引用，主要需要找到在实际运行时内存布局方法的实际地址。

1、解析
只有在“编译器可知，运行时不变”的方法，才会在解析阶段将符号引用转为直接引用，如静态方法和私有方法。
5条方法字节码调用指令：
invokestatic:调用静态方法（可在解析阶段确定唯一版本）
invokespecial:调用<init>、私有方法、父类方法（可在解析阶段确定唯一版本）
invokeinterface:调用接口方法
invokevirtual：调用所有的虚方法，实例方法，可重写
invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
注：final方法也是一种非虚方法，无法被覆盖

2、分派
（1）静态分派（主要与重载有关）
虚拟在在重载时是根据变量的静态类型进行分派而不是实际类型
Human man = new Man(); // 其中Human表示变量的静态类型，而Man表示变量的实际类型。
依赖静态类型来定位方法的分派动作称为静态分派，静态分派发生在编译期（重载是常见的静态分派）
静态分派过程即选择最合适版本的过程

（2）动态分派（主要与重写有关）
在运行期间根据实际类型确定方法执行版本的分派过程称为动态分派
java是目前是一门静态多分派、动态单分派的语言。

（3）虚拟机动态分派的实现
为了降低“搜索”的复杂性，为每一个类在方法区中建立了虚方法表，使用虚方法表索引来代替元数据查找以提高性能。虚方法表存放着各个方法的入口地址
方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。
“稳定优化”手段还包括内联缓存和基于“类型继承关系分析”技术的守护内联手段。

3、动态类型语言支持
注：运行时异常是很难发现的bug，因为代码不运行到这一行，就检测不到错误
（1）与运行时异常相对应的是连接时异常，连接时异常就算放到一段无法执行到的代码处，类加载时也会抛出异常
（2）invokedynamic指令是为了解决分派规则固化在虚拟机中，将分派规则提取到用户代码中
