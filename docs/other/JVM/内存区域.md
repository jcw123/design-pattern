一、运行时数据区
1、程序计数器
（1）每个线程有一个自己的程序计数器
（2）用来指示当前所执行指令的地址，定位行号
（3）线程切换过程中也可以方便恢复正确的执行位置
2、Java虚拟机栈
（1）也是线程私有的
（2）虚拟机栈的基本单位，进入一个方法就会创建一个新的栈帧
（3）栈帧的存储：局部变量表、操作数栈、动态链接、方法出口
3、本地方法栈
（1）线程私有
（2）和虚拟机栈功能很类似，虚拟机栈为Java方法服务，本地方法栈为Native方法服务
4、Java堆
（1）所有线程共享的一块内存区域
（2）主要用来存放内存实例
5、方法区
>  相当于存储一些不变的信息，和类绑定的信息，不是类实例独有的；

（1）线程共享的内存区域
（2）用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
（3）内存回收针对于这一块主要对常量池的回收和类型的卸载
6、运行时常量池
（1）属于方法区的一部分
（2）主要用于存放编译期生成的各种字面量和符号引用，当然也有一部分运行时确认的常量放到运行时常量池
7、直接内存
（1）不属于虚拟机运行时数据区的一部分；

二、对象的创建
1、如果类还没有进行加载，首先进行相应类的加载（就是生成类的Class对象）、解析、初始化
2、为新对象分配内存，当类加载完毕后，一个实例所需要的内存大小就已经确定
3、为了保证分配内存的线程安全性，有两种解决方案：对分配内存空间的动作进行同步操作-虚拟机采用CAS配上失败重试
保证更新操作的原子性；另一种把内存分配的动作按照线程分配到不同的空间进行（本地线程分配缓存【Thread Local Allocaton Buffer， TLAB】）
4、内存分配完毕后，虚拟机需要将分配到的内存空间都初始化为零值
5、接下来对对象进行必要的设置，例如这个对象属于哪个类的实例、如果才能找到类的元数据信息、对象的哈希吗、对象的
GC分代年龄信息等。
6、从虚拟机角度来看，一个新的对象产生了，从Java程序的角度来看，对象的创建刚刚开始，<init>方法还没有执行，所有的字段都还为零。

<init>方法是new一个对象时执行的，进行成员变量的初始化；
<clinit>方法是Class对象的初始化时执行的，执行static block和进行static变量的初始化；父类的<clinit>方法优先于子类的<clinit>先执行；

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞（）方法。 但接口与类不同的是，执行接口的＜clinit＞（）方法不需要先执行父接口的＜clinit＞（）方法。 只有当父接口中定义的变量使用时，父接口才会初始化。 另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞（）方法；接口中的属性都是static final类型的常量，因此在准备阶段就已经初始化；

三、对象的内存布局
> 对象在内存中粗出的布局分为三部分: 对象头(Header)、实例数据（Instance Data）和对齐填充（Padding）

1、对象头
（1）对象头包含两部分信息：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁（哪个线程持有这个锁？）、偏向线程ID、偏向时间戳等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定对象属于哪个类的实例
2、对象实例部分
（1）存储的是程序代码中所定义的各种类型的字段内容；包括从父类中继承过来的和在子类中定义的
3、对齐填充
（1）这部分内容不是必须的，只是为了保证对象的起始地址是8字节的整数倍

四、对象的访问定位
1、通过栈上存储的reference数据来操作堆上的具体数据
2、有两种访问方式：使用句柄（间接访问）和直接指针访问
