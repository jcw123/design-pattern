一、判断对象是存活还是死亡
1、引用计数法
（1）给一个对象添加一个计数器，每当有一个地方引用时，计数器加一，当引用的地方销毁时，引用减一。
（2）引用计数法很难解决对象之间循环引用的问题。
2、可达性分析算法
（1）根节点称之为GC Roots，GC Roots不可达的节点称之为可回收节点
（2）GC Roots包含以下几种:
1)虚拟机栈（栈帧中的局部变量表）中引用的对象
2）方法区中类静态属性引用的对象
3）方法区中常量引用的对象
4）本地方法栈中JNI（Native方法）引用的对象
3、引用
（1）强引用
类似Object = new Object()，只要强引用存在，垃圾收集器永远不会回收掉引用的对象
（2）软引用
通过SoftReference类来实现软引用，当在发生内存溢出异常之前，尝试回收软引用对象
（3）弱引用
通过WeakReference类来实现弱引用，被引用的对象只能生存到下一次垃圾收集发生之前
（4）虚引用
通过PhantomReference类来实现虚引用，设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
4、回收还是死亡
当一个对象经过可达性分析之后，GC Roots不可达，不一定是立即回收的，要经过两次标记阶段，第一次标记并进行筛选，筛选的条件就是判断对象是否有必要执行finalize方法；如果对象没有覆盖finalize方法或者已经执行过finalize方法，将没必要执行finalize方法，如果有必要执行时会将这个对象放到F-Queue队列中，由一个专门的Finalizer线程触发对象的finalize方法，如果执行finalize方法后，方法又可达，则可从垃圾回收中逃逸。
5、方法区回收
(1)回收的内容包含两种：废弃的常量；无用的类
1）废弃的常量：没有任何String对象引用常量池的“abc”常量，也没有其他地方引用了这个字面量
2）无用的类：需要同时满足下面三个条件-》该类所有的实例都被回收；加载该类的classLoader已经被回收；该类对应的Class对象没有在其他任何地方被引用

二、垃圾收集算法
1、标记-清除算法
（1）两个主要不足：标记和清除过程效率都不高；空间问题，标记清除之后会产生大量不连续的内存碎片，如果大对象来了，可能无法找到一块合适的空间，又触发垃圾回收
22、复制算法
复制算法是将内存划分为大小相等的两块，先使用其中的一块，当这一块满后，将这块还存活的对象移到另一块中，然后将之前使用的一块中的所有对象都清除（注：如果存活的对象少，这个算法优势很大，如果存活对象很多，这种算法效率也不高）；
主要缺点：将内存缩小了一半，严重浪费了空间
3、标记-整理算法
标记过程和“标记-清除”算法一致，标记完之后不是对可回收对象进行操作，而是将存活对象向一端移动，然后清理掉边界以外的内存
4.分代收集算法
像Java就将堆分为新生代和老年代，然后根据各个年代的特点，选择合适的收集算法

三、HotSpot算法实现
1、枚举根节点
通过OopMap数据结构来存储什么位置是什么类型数据，每次寻找GC Roots时不再需要全部遍历，直接从数据结构对象中获取
2、安全点（Safepoint）
要进行垃圾回收，需要让所有线程进入安全点；安全点选定标准：程序“是否具有让程序长时间执行的特征”，例如：方法调用、循环跳转、异常跳转等。
3、安全区域
是安全点的扩展，对于没有占用时间片的线程，无法响应中断请求进入安全点，当线程进入安全区域时就标识自己进入了安全区域，如果根节点没有枚举完或者垃圾收集还没有结束时，线程就在安全区域等待。

四、垃圾收集器
1、Serial收集器（新生代收集器）
单线程收集器，进行垃圾收集时需要暂停所有的工作线程，作用于年轻代的垃圾收集
2、ParNew收集器（新生代收集器）
是Serial收集器的多线程版本，除了采用多条线程进行垃圾收集之外，其余的行为和Serial收集器一模一样
3、Parallel Scanvange收集器（新生代收集器）
(1)达到可控制的吞吐量，即时CG的总时间尽可能小，吞吐量=运行用户代码时间/(运行代码时间+垃圾收集时间)
（2）有自适应调节策略，可以配置-XX:+UseAdaptiveSizePolicy参数，其他细节缠住不用配置，可以根据性能监控参数动态调整
4、Serial Old收集器（与PS MarkSweep实现非常类似，可以认为一样）
（1）是Serial收集器的老年代版本，也是一个单线程收集器
（2）可以与Parallel Scavenge配合使用，同时可以作为CMS收集器的后备预案
5、Parallel Old收集器
（1）是Parallel Scanvenge收集器的老年代版本
（2）只能和Parallel Scanvenge配合使用
6、CMS收集器（Concurrent Mark Sweep）
（1）以获取最短回收停顿时间为目标的收集器
（2）基于标记-清除算法实现的
（3）四个主要步骤：初始标记、并发标记、重新标记、并发清除
初始标记和重新标记阶段需要“Stop the world”，初始标记：标记一下GC Roots能直接关联到的对象；并发标记：进行GC Roots Tracing过程；重新标记：为了修正并发标记阶段用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；
（4）三个主要缺点：CMS收集器对CPU资源非常敏感；无法处理浮动垃圾（标记过程之后产生的垃圾）；因为是基于标记-清除算法，以产生大量空间碎片
7、G1收集器
（1）主要特点：并行和并发、分代收集、空间整合、可预测的停顿
（2）主要步骤：初始标记、并发标记、最终标记、筛选回收


五、内存分配策略和回收策略
1、对象优先在Eden分配
都Eden区剩余的连续空间无法支持新对象的分配时，就触发Minor GC
2、大对象直接进入老年代
配置-XX:PretenureSizeThreshold参数，控制当对象的大小大于多少时，可以令大于这个值的对象直接进入老年代，主要是为了防止Eden去和两个Survior区之间进行大量的内存复制。
3、内存分配和回收过程
初始化是，首先对象先进入Eden区，当Eden区满后，将对象复制到S0区，此时Eden区为空，对象再次过来时进入Eden区，当Eden区满后，将Eden区和S0区存活的对象复制到S1，区，同时交换S1和S0的角色。当复制过程S1区满后，过早将一些对象复制到老年代，当老年代也满后，触发Full GC。
4、长期存活的对象进入老年代
通过参数-XX:MaxTenuringThreshold来设置对象熬过来了几次Minor GC后直接进入老年代
5、空间分配担保
就是通过老年代进行空间担保，老年代存放的并不一定是长期存活的对象，有可能由于过早提升导致一些对象进入老年代。
