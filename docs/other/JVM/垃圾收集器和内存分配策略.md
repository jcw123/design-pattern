一、判断对象是存活还是死亡
1、引用计数法
（1）给一个对象添加一个计数器，每当有一个地方引用时，计数器加一，当引用的地方销毁时，引用减一。
（2）引用计数法很难解决对象之间循环引用的问题。
2、可达性分析算法
（1）根节点称之为GC Roots，GC Roots不可达的节点称之为可回收节点
（2）GC Roots包含以下几种:
1)虚拟机栈（栈帧中的局部变量表）中引用的对象
2）方法区中类静态属性引用的对象
3）方法区中常量引用的对象
4）本地方法栈中JNI（Native方法）引用的对象
3、引用
（1）强引用
类似Object = new Object()，只要强引用存在，垃圾收集器永远不会回收掉引用的对象
（2）软引用
通过SoftReference类来实现软引用，当在发生内存溢出异常之前，尝试回收软引用对象
（3）弱引用
通过WeakReference类来实现弱引用，被引用的对象只能生存到下一次垃圾收集发生之前
（4）虚引用
通过PhantomReference类来实现虚引用，设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
4、回收还是死亡
当一个对象经过可达性分析之后，GC Roots不可达，不一定是立即回收的，要经过两次标记阶段，第一次标记并进行筛选，筛选的条件就是判断对象是否有必要执行finalize方法；如果对象没有覆盖finalize方法或者已经执行过finalize方法，将没必要执行finalize方法，如果有必要执行时会将这个对象放到F-Queue队列中，由一个专门的Finalizer线程触发对象的finalize方法，如果执行finalize方法后，方法又可达，则可从垃圾回收中逃逸。
5、方法区回收
(1)回收的内容包含两种：废弃的常量；无用的类
1）废弃的常量：没有任何String对象引用常量池的“abc”常量，也没有其他地方引用了这个字面量
2）无用的类：需要同时满足下面三个条件-》该类所有的实例都被回收；加载该类的classLoader已经被回收；该类对应的Class对象没有在其他任何地方被引用

二、垃圾收集算法
1、标记-清除算法
（1）两个主要不足：标记和清除过程效率都不高；空间问题，标记清除之后会产生大量不连续的内存碎片，如果大对象来了，可能无法找到一块合适的空间，又触发垃圾回收
2、复制算法
复制算法是将内存划分为大小相等的两块，先使用其中的一块，当这一块满后，将这块还存活的对象移到另一块中，然后将之前使用的一块中的所有对象都清除（注：如果存活的对象少，这个算法优势很大，如果存活对象很多，这种算法效率也不高）；
主要缺点：将内存缩小了一半，严重浪费了空间
3、标记-整理算法
标记过程和“标记-清除”算法一致，标记完之后不是对可回收对象进行操作，而是将存活对象向一端移动，然后清理掉边界以外的内存
4.分代收集算法
像Java就将堆分为新生代和老年代，然后根据各个年代的特点，选择合适的收集算法
