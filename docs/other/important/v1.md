1、MVCC
Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。

2、乐观锁大部分情况下是通过版本号进行控制的。

3、介绍java中各种锁的实现文章：
https://zhuanlan.zhihu.com/p/71156910

4、synchronized和ReentrantLock的区别？
（1）synchronized是java原生支持的关键字，ReentrantLock是借助于AQS框架实现的。
（2）synchronized能够实现的加锁方式，ReentrantLock都能实现，并在此机制上扩充了一些功能，
比如提供了公平锁和非公平锁的机制，

5、悲观锁和乐观锁
（1）悲观锁和乐观锁并不是指的某一种具体的锁，而是在并发场景下的一种策略。
（2）在Java中乐观锁主要是借助于CAS实现的，CAS是一个原子操作。
（3）乐观锁其实并没有加锁，通过循环重试进行数据更改（需要保证业务场景下很少的几次就能更新成功）
（4）乐观锁在更新时会检查在读取至更新这段时间别人是否修改过数据，如果修改过需要重试，悲观锁
阻塞事务，乐观锁回滚事务。

6、synchronized锁升级：偏向锁 -》 轻量级锁 -》重量级锁
当一个线程A获取锁后，会首先修改对象头将锁标志位偏向锁，此时线程A退出同步方法后偏向锁并不释放的，只有
如果线程A再进入就不需要进行锁操作了。但是如果有个线程B来获取锁，且线程A还存活，会将偏向锁升级为轻量级
锁（自旋锁）。之后如果一个线程等待获取锁自旋次数超过阈值，还会将轻量级锁升级为重量级锁，这个过程就是
锁膨胀。
偏向锁：如果只有一个线程获取锁，只会第一次有加锁的操作，后续不会再加锁了，省去了加锁的开销。
轻量级锁：线程只会进行空转，不会进行用户态和内核态的切换，省去了线程切换的开销。

7、共享锁、互斥锁
一个线程获取到这个锁后，其他线程还是同样可以获取到此锁。
互斥锁是同一时刻只能有一个线程持有。

8、公平锁、非公平锁
公平锁：等待时候更久的线程优先获取锁；
非公平锁：不管有没有线程等待获取锁，都首先尝试获取锁。
