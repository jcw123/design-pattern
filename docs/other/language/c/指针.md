1. char \*s = "hello, world";
```c
char *message = "hello, world";

char *message2;
message2 = "hello, world";
```

2. 创建新的类型名，使用typedef而不是#define， 后者无法正确地处理指针类型。
```c
#define d_ptr_to_char char *

// 只能正确地声明a是指针类型，而b还是字符类型；
d_ptr_to_char a, b;
```

3. 常量和指针
```c
//  普通的执行指向整型的常量
int *pci;

// 指向整型常量的指针，可以修改指针的值，但是不能修改它所指向的值；
int const *pci;

// pci为指向整型的常量指针；指针的值不能修改；
int * const pci;

// 无论指针本身还是它所指向
int const * const pci;

```

4. 整型常量是可以强转为指针类型的
```c
int a = 100;
int *b = (int \*)a;
```

5. 指针的指针
```c
int a = 1;
int *b = &a;
int **c = &b;
```

6. 指针表达式

> 学习c的时候就被这个搞的头大

```c
char ch = 'a';
char *cp = &ch;

// 左值和右值分别代表的含义

// 右值：变量ch的地址； 左值：非法
&ch;

// 左值：cp所处的内存位置；右值：cp的值
cp;

// 左值：非法；右值：指针变量的地址；
&cp;

// 左值：cp值所指向的地址； 右值：cp所所指向地址的值；
*cp;

// 左值：非法； 右值：cp所指向地址的值的拷贝进行加1操作；
*cp + 1;

// 左值：cp所指向的地址进行加1，表示这个位置的地址；右值：cp所指向的地址进行加1，表示这个位置的值；
*(cp + 1);

//左值：非法；右值：返回cp所指向的地址加1；并且cp指向原来位置的下一个位置；
++cp;

// 左值：非法；右值：返回的是cp所指向的地址，并且cp指向原来位置的下一个位置；
cp++;

// 左值：cp所指向的地址的下一个地址的值；cp所指向的地址的下一个地址
*++cp;

// 左值：cp所指向的地址的值；右值：cp所指向的地址；注：cp会指向下一个地址；
*cp++;

// 左值：非法；右值：首先执行间接访问，然后将cp所指向的位置的值增加1，最后返回这个增加值的一份拷贝；
++*cp;

// 左值：非法；右值：返回cp指向位置的值，然后将指向位置的值进行加1操作；
(*cp)++;

// 左值：非法 ；右值：将cp所指向位置的下一个位置的值进行加1操作并返回；
++*++cp;

// 左值：非法； 右值：先返回cp的拷贝；然后将cp的值加1，然后间接访问cp的拷贝位置的值，然后将这个位置的值进行加1操作；
++\*cp++;
```

7. 字符串通常以'\0'表示结尾，而指针类型通常以NULL表示结尾
